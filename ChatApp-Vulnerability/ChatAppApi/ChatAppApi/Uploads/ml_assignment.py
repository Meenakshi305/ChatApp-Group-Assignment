# -*- coding: utf-8 -*-
"""ml Assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e7JjyPuZiJ-49Za_UxCPE_33F6YmUHf7

My analysis is based on official Kaggle datasets:

**I have used following datasets from Kaggle:**

1.   “120 Years of Olympic History: Athletes and Results” – comprehensive data from 1896 to 2016.

2.   "2021 Tokyo Olympics – Dive Deep in SQL” – structured querying approach.


3.   “Paris 2024 Olympics Medals Visualization” – forward-looking, interactive designs.

# Data Creation
"""

import pandas as pd

paris_df_atl = pd.read_csv('/content/athletes_25.csv')
print('participants,',paris_df_atl.columns)

paris_df_medalist = pd.read_csv('/content/medallists_25.csv')
print('medalist,',paris_df_medalist.columns)

import pandas as pd

# Rename code_athlete to code to match participants
paris_df_medalist = paris_df_medalist.rename(columns={'code_athlete': 'code'})

# Merge medal info (type) from medalist dataset
paris_df_combined = paris_df_atl.merge(
    paris_df_medalist[['code', 'medal_type', 'medal_date', 'event']],  # only relevant columns
    on='code',
    how='left'
)

# Add a Medal column: Yes/No
paris_df_combined['Medal'] = paris_df_combined['medal_type'].notnull().map({True: 'Yes', False: 'No'})

# Fill missing medal_type with "None" for non-medalists
paris_df_combined['medal_type'] = paris_df_combined['medal_type'].fillna("None")

columns_to_keep = ['name', 'country', 'gender', 'birth_date', 'disciplines',
                   'events', 'Medal', 'medal_type', 'medal_date', 'event']
combined_df = paris_df_combined[columns_to_keep]

combined_df.to_excel("Paris2024_Combined_Athletes.xlsx", index=False)
print("Excel file created: Paris2024_Combined_Athletes.xlsx")

import pandas as pd

paris = pd.read_excel('/content/Paris2024_Combined_Athletes.xlsx')
print(paris.columns)

paris.head(200)

olympicdf = pd.read_csv('/content/120 years of Olympic.csv')

olympicdf.columns

import pandas as pd

athletes_21 = pd.read_excel('/content/Athletes21.xlsx')
medals_21 = pd.read_excel('/content/Medals21.xlsx')
print('participants,',
athletes_21.columns)
print('medalist,',
medals_21.columns)

athletes_per_country = athletes_21.groupby('NOC').size().reset_index(name='Num_Athletes')

combined_df_21 = pd.merge(
    athletes_per_country,
    medals_21,
    left_on='NOC',
    right_on='Team/NOC',
    how='left'
)

# Fill countries with no medals with 0
for col in ['Gold', 'Silver', 'Bronze', 'Total']:
    combined_df_21[col] = combined_df_21[col].fillna(0)

combined_df_21.to_excel("Tokyo_Medal_for_country.xlsx", index=False)
print("Excel file created: Tokyo_Medal_for_country.xlsx")
combined_df_21.head()

# Load datasets
paris_df = pd.read_excel("/content/Paris2024_Combined_Athletes.xlsx")
tokyo_df = pd.read_excel("/content/Tokyo_Medal_for_country.xlsx")
olympic_120yrs_df = pd.read_csv("/content/120 years of Olympic.csv")

# Print columns of each
print("Columns in Paris 2024 dataset:")
print(paris_df.columns)

print("\nColumns in Tokyo dataset:")
print(tokyo_df.columns)

print("\nColumns in 120 Years Olympic dataset:")
print(olympic_120yrs_df.columns)

"""# Data Cleaning"""

print("=== Paris 2024: Original Dataset ===")
print(paris_df.head(), "\n")

# 1️⃣ Remove duplicates
paris_df.drop_duplicates(inplace=True)
print("After Removing Duplicates:")
print(paris_df.head(), "\n")

# 2️⃣ Handle missing values for 'Medal'
paris_df['Medal'] = paris_df['Medal'].fillna('No')
print("After Filling Missing 'Medal' Values:")
print(paris_df.head(), "\n")

# 3️⃣ Standardize column names
paris_df.rename(columns={'name':'Name', 'country':'Country', 'gender':'Gender'}, inplace=True)
print("After Renaming Columns:")
print(paris_df.head(), "\n")

# 4️⃣ Reset index
paris_df.reset_index(drop=True, inplace=True)
print("After Resetting Index:")
print(paris_df.head(), "\n")

print("Paris 2024 cleaned shape:", paris_df.shape)

print("=== Tokyo 2020: Original Dataset ===")
print(tokyo_df.head(), "\n")

# 1️⃣ Remove duplicates
tokyo_df.drop_duplicates(inplace=True)
print("After Removing Duplicates:")
print(tokyo_df.head(), "\n")

# 2️⃣ Fill missing medal counts with 0
for col in ['Gold', 'Silver', 'Bronze', 'Total']:
    tokyo_df[col] = tokyo_df[col].fillna(0)
print("After Filling Missing Medal Counts:")
print(tokyo_df.head(), "\n")

# 3️⃣ Standardize column names
tokyo_df.rename(columns={'NOC':'Country_Code'}, inplace=True)
print("After Renaming Columns:")
print(tokyo_df.head(), "\n")

# 4️⃣ Reset index
tokyo_df.reset_index(drop=True, inplace=True)
print("After Resetting Index:")
print(tokyo_df.head(), "\n")

print("Tokya 2021 cleaned shape:", tokyo_df.shape)

print("=== 120 Years Olympic: Original Dataset ===")
print(olympic_120yrs_df.head(), "\n")

# 1️⃣ Remove duplicates
olympic_120yrs_df.drop_duplicates(inplace=True)
print("After Removing Duplicates:")
print(olympic_120yrs_df.head(), "\n")

# 2️⃣ Handle missing values
olympic_120yrs_df['Medal'] = olympic_120yrs_df['Medal'].fillna('None')
olympic_120yrs_df['Age'] = pd.to_numeric(olympic_120yrs_df['Age'], errors='coerce')
print("After Filling Missing Values and Converting Age:")
print(olympic_120yrs_df.head(), "\n")

# 3️⃣ Standardize column names
olympic_120yrs_df.rename(columns={'Sex':'Gender'}, inplace=True)
print("After Renaming Columns:")
print(olympic_120yrs_df.head(), "\n")

# 4️⃣ Reset index
olympic_120yrs_df.reset_index(drop=True, inplace=True)
print("After Resetting Index:")
print(olympic_120yrs_df.head(), "\n")

print("Past 120 years  before 2021 cleaned shape:", olympic_120yrs_df.shape)

"""# Feature Engineering"""

# Paris 2024: Medal_Won binary
paris_df['Medal_Won'] = paris_df['Medal'].apply(lambda x: 1 if x != 'No' else 0)
print("Paris 2024 - Medal_Won column added:")
print(paris_df[['Name','Country','Medal','Medal_Won']].head(), "\n")

# Total medals per country
paris_country_medals = paris_df.groupby('Country')['Medal_Won'].sum().reset_index()
paris_country_medals.rename(columns={'Medal_Won':'Total_Medals'}, inplace=True)
print("Paris 2024 - Total Medals per Country:")
print(paris_country_medals.sort_values(by='Total_Medals', ascending=False).head(), "\n")

# Tokyo 2020: Medal Efficiency
tokyo_df['Medal_Efficiency'] = tokyo_df['Total'] / tokyo_df['Num_Athletes']
print("Tokyo 2020 - Medal_Efficiency added:")
print(tokyo_df[['Country_Code','Num_Athletes','Total','Medal_Efficiency']].head(), "\n")

# Medal_Won binary
olympic_120yrs_df['Medal_Won'] = olympic_120yrs_df['Medal'].apply(lambda x: 1 if x != 'None' else 0)
print("120 Years Olympic - Medal_Won column added:")
print(olympic_120yrs_df[['Name','Year','Sport','Medal','Medal_Won']].head(), "\n")

# Age Groups
olympic_120yrs_df['Age_Group'] = pd.cut(
    olympic_120yrs_df['Age'],
    bins=[0,20,30,40,100],
    labels=['<20','20-30','30-40','40+']
)
print("120 Years Olympic - Age_Group column added:")
print(olympic_120yrs_df[['Name','Age','Age_Group']].head(), "\n")

import pandas as pd

# -----------------------------
# 1️⃣ Load 2021 athletes
# -----------------------------
athletes_21_df = pd.read_excel("/content/Athletes21.xlsx")  # Tokyo 2021 athletes
athletes_21 = set(athletes_21_df['Name'])  # get set of athlete names

# -----------------------------
# 2️⃣ Add a new column in Paris 2024 dataset
# -----------------------------
paris_df['Played_2021'] = paris_df['Name'].apply(lambda x: 1 if x in athletes_21 else 0)

# -----------------------------
# 3️⃣ Print sample
# -----------------------------
print("Paris 2024 - Sample with returning athletes from 2021:")
print(paris_df[['Name','Country','Medal','Played_2021']].head(10))

# -----------------------------
# 4️⃣ Optional: Count total returning athletes
# -----------------------------
total_returning = paris_df['Played_2021'].sum()
print(f"\nTotal athletes who played in 2021 and are in 2024: {total_returning}")

import pandas as pd

# Load 2021 athletes
athletes_21_df = pd.read_excel("/content/Athletes21.xlsx")

athletes_21_df.columns

# Check unique disciplines
unique_disciplines_21 = athletes_21_df['Discipline'].unique()
print("Unique disciplines in 2021 dataset:")
for d in unique_disciplines_21:
    print(d)

paris_df.columns

unique_disciplines_24 = paris_df['disciplines'].unique()
print("Unique disciplines in 2024 dataset:")
for d in unique_disciplines_24:
    print(d)

# Filter badminton players in 2021
badminton_21 = set(athletes_21_df[athletes_21_df['Discipline'].str.contains("Golf", case=False)]['Name'])

# -----------------------------
# 2️⃣ Filter Paris 2024 badminton players
# -----------------------------
paris_badminton_df = paris_df[paris_df['disciplines'].str.contains("Golf", case=False)].copy()

# Flag returning athletes from 2021
paris_badminton_df['Played_2021'] = paris_badminton_df['Name'].apply(lambda x: 1 if x in badminton_21 else 0)

# -----------------------------
# 3️⃣ Get only returning badminton players
# -----------------------------
returning_badminton_df = paris_badminton_df[paris_badminton_df['Played_2021'] == 1]

# -----------------------------
# 4️⃣ Print returning players
# -----------------------------
print("Badminton players who played in both 2021 and 2024:")
print(returning_badminton_df[['Name','Country','Medal']].reset_index(drop=True))

# Optional: Count
print(f"\nTotal returning badminton players: {len(returning_badminton_df)}")

# Unique disciplines in 2021
disciplines_21 = set(athletes_21_df['Discipline'].unique())
print(f"Disciplines in 2021 (Total {len(disciplines_21)}):")
print(disciplines_21, "\n")

# Unique disciplines in Paris 2024
disciplines_24 = set(paris_df['disciplines'].unique())
print(f"Disciplines in Paris 2024 (Total {len(disciplines_24)}):")
print(disciplines_24, "\n")

# Find missing disciplines (in 2021 but not in 2024)
missing_disciplines = disciplines_21 - disciplines_24
print(f"Disciplines in 2021 missing in 2024 (Total {len(missing_disciplines)}):")
print(missing_disciplines)

# Create Age_Category column
paris_selected['Age_Category'] = paris_selected['Age'].apply(lambda x: '>30' if x > 30 else '≤30')

# Check the result
print("Paris 2024 - Age Category added:")
print(paris_selected[['Name','Age','Age_Category']].head(20))

# Sort by Year so the earliest participation comes first
olympic_120_selected.sort_values(['Name','NOC','Year'], inplace=True)

# Keep the first record per athlete per country
olympic_120_first = olympic_120_selected.groupby(['Name','NOC']).head(1).reset_index(drop=True)

# Add Age_Category if needed
olympic_120_first['Age_Category'] = olympic_120_first['Age'].apply(lambda x: '>30' if x > 30 else '≤30')

# Check the result
print("120 Years Olympic - First participation per athlete:")
print(olympic_120_first[['Name','NOC','Year','Age','Age_Category']].head(200))

"""
# `Feature Selection
`"""

# Paris 2024
paris_selected = paris_df[['Name','Country','Gender','birth_date','disciplines','events','Medal','medal_type']]
print("Paris 2024 - Selected Columns:")
print(paris_selected.head(), "\n")

tokyo_df.columns

# Tokyo 2021
tokyo_selected = tokyo_df[['Country_Code','Num_Athletes','Gold','Silver','Bronze','Total']]
print("Tokyo 2021 - Selected Columns:")
print(tokyo_selected.head(), "\n")

# 120 Years Olympic
olympic_120_selected = olympic_120yrs_df[['Name','Gender','Age','Height','Weight','Team','NOC','Games','Year','Sport','Event','Medal']]
print("120 Years Olympic - Selected Columns:")
print(olympic_120_selected.head(), "\n")

"""# **2️ Data Transforms**"""

# 120 Years: Min-Max scaling for Age, Height, Weight
for col in ['Age','Height','Weight']:
    olympic_120_selected[col+'_scaled'] = (olympic_120_selected[col] - olympic_120_selected[col].min()) / (olympic_120_selected[col].max() - olympic_120_selected[col].min())

print("120 Years Olympic - Scaled numeric columns:")
print(olympic_120_selected[['Name','Age','Age_scaled','Height','Height_scaled','Weight','Weight_scaled']].head())

paris_selected = paris_df[['Name','birth_date']].copy()

# Convert to datetime
paris_selected['birth_date'] = pd.to_datetime(paris_selected['birth_date'], errors='coerce')

# Calculate Age based on a reference date (e.g., Paris 2024 start date)
reference_date = pd.to_datetime('2024-07-26')
paris_selected['Age'] = (reference_date - paris_selected['birth_date']).dt.days // 365

# Check result
print(paris_selected.head(45))

older_athletes = paris_selected[paris_selected['Age'] > 30]
print("Paris 2024 - Athletes older than 30:")
print(older_athletes.head(45))

"""# Dimension Reduction

"""

import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA
from sklearn.impute import SimpleImputer

# Assuming olympic_120_selected is your DataFrame
# Select numeric columns for PCA
numeric_cols = ['Age','Height','Weight']
numeric_data = olympic_120_selected[numeric_cols]

# Step 1: Handle missing values using mean imputation
imputer = SimpleImputer(strategy='mean')
numeric_data_imputed = imputer.fit_transform(numeric_data)

# Step 2: Scale numeric columns (0-1 range)
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(numeric_data_imputed)

# Step 3: Apply PCA to reduce to 2 components
pca = PCA(n_components=2)
pca_result = pca.fit_transform(scaled_data)

# Step 4: Add PCA results back to DataFrame
olympic_120_selected['PCA1'] = pca_result[:,0]
olympic_120_selected['PCA2'] = pca_result[:,1]

# Step 5: Inspect the result
print("120 Years Olympic - PCA Components added:")
print(olympic_120_selected[['Name','Year','Age','Height','Weight','PCA1','PCA2']].head())

paris_df_atl.columns

import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA
from sklearn.impute import SimpleImputer

# Step 1: Calculate Age from birth_date
paris_df_atl['birth_date'] = pd.to_datetime(paris_df_atl['birth_date'], errors='coerce')
paris_df_atl['Age'] = (pd.Timestamp('2024-07-26') - paris_df_atl['birth_date']).dt.days // 365

# Step 2: Select numeric columns for PCA
paris_numeric_cols = ['Age','height','weight']
paris_numeric_data = paris_df_atl[paris_numeric_cols]

# Step 3: Handle missing values
imputer = SimpleImputer(strategy='mean')
paris_imputed = imputer.fit_transform(paris_numeric_data)

# Step 4: Scale numeric features
scaler = MinMaxScaler()
paris_scaled = scaler.fit_transform(paris_imputed)

# Step 5: Apply PCA (2 components)
pca = PCA(n_components=2)
paris_pca_result = pca.fit_transform(paris_scaled)

# Step 6: Add PCA results back to DataFrame
paris_df_atl['PCA1'] = paris_pca_result[:,0]
paris_df_atl['PCA2'] = paris_pca_result[:,1]

# Step 7: Check result
print("Paris 2024 - PCA added with Age, Height, Weight:")
print(paris_df_atl[['name','Age','height','weight','PCA1','PCA2']].head(10))

combined_df_21.columns

from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA
from sklearn.impute import SimpleImputer

# Step 1: Create Medal_Efficiency column
combined_df_21['Medal_Efficiency'] = combined_df_21['Total'] / combined_df_21['Num_Athletes']

# Step 2: Select numeric columns for PCA
tokyo_numeric_cols = ['Num_Athletes','Gold','Silver','Bronze','Total','Medal_Efficiency']
tokyo_numeric_data = combined_df_21[tokyo_numeric_cols]

# Step 3: Handle missing values
imputer = SimpleImputer(strategy='mean')
tokyo_imputed = imputer.fit_transform(tokyo_numeric_data)

# Step 4: Scale numeric features
scaler = MinMaxScaler()
tokyo_scaled = scaler.fit_transform(tokyo_imputed)

# Step 5: Apply PCA (2 components)
pca = PCA(n_components=2)
tokyo_pca_result = pca.fit_transform(tokyo_scaled)

# Step 6: Add PCA results back to DataFrame
combined_df_21['PCA1'] = tokyo_pca_result[:,0]
combined_df_21['PCA2'] = tokyo_pca_result[:,1]

# Step 7: Check result
print("Tokyo 2021 - PCA added:")
print(combined_df_21[['NOC','Num_Athletes','Total','Medal_Efficiency','PCA1','PCA2']].head(10))

"""# Visualizations"""

import matplotlib.pyplot as plt
import seaborn as sns

# Create Age_Category if not already present
paris_df_atl['Age_Category'] = paris_df_atl['Age'].apply(lambda x: '≤30' if x <= 30 else '>30')

plt.figure(figsize=(10,6))
sns.scatterplot(
    x='PCA1',
    y='PCA2',
    hue='gender',           # Using gender instead of Medal
    style='Age_Category',   # ≤30 / >30
    data=paris_df_atl,
    palette='Set1',
    s=100
)
plt.title("Paris 2024 Athletes - PCA1 vs PCA2")
plt.xlabel("PCA1")
plt.ylabel("PCA2")
plt.legend(bbox_to_anchor=(1.05, 1), loc=2)
plt.show()

paris_country_medals_sorted = paris_country_medals.sort_values(by='Total_Medals', ascending=False)
plt.figure(figsize=(12,6))
sns.barplot(x='Country', y='Total_Medals', data=paris_country_medals_sorted, palette='Blues_d')
plt.title("Paris 2024 - Total Medals by Country")
plt.xlabel("Country")
plt.ylabel("Total Medals")
plt.xticks(rotation=90)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10,6))
sns.scatterplot(
    x='PCA1',
    y='PCA2',
    hue='Total',             # Total medals
    size='Num_Athletes',     # Team size
    sizes=(50, 300),
    data=combined_df_21,
    palette='viridis'
)
plt.title("Tokyo 2021 Countries - PCA1 vs PCA2")
plt.xlabel("PCA1")
plt.ylabel("PCA2")

# Move the legend outside the plot
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()

top10_tokyo = combined_df_21.sort_values(by='Total', ascending=False).head(10)
plt.figure(figsize=(10,5))
sns.barplot(x='NOC', y='Total', data=top10_tokyo, palette='magma')
plt.title("Tokyo 2021 - Top 10 Countries by Total Medals")
plt.xlabel("Country")
plt.ylabel("Total Medals")
plt.show()

# Total medals per year
medals_per_year = olympic_120yrs_df.groupby('Year')['Medal_Won'].sum().reset_index()

plt.figure(figsize=(12,6))
sns.lineplot(x='Year', y='Medal_Won', data=medals_per_year, marker='o', color='b')
plt.title("Total Medals Over the Years (120 Years Olympics)")
plt.xlabel("Year")
plt.ylabel("Total Medals")
plt.grid(True)
plt.show()

import plotly.express as px

india_medal_winners = paris_df_combined[
    (paris_df_combined['Medal'].notna()) & (paris_df_combined['country'] == 'India')
]

# Count by Gender
medal_gender_counts = india_medal_winners['gender'].value_counts().reset_index()
medal_gender_counts.columns = ['Gender', 'Count']

# Plot pie chart
fig = px.pie(
    medal_gender_counts,
    names='Gender',
    values='Count',
    title='Paris 2024: Medal Winners by Gender (India)'
)
fig.update_traces(textinfo='label+percent')
fig.show()

paris_df_combined.columns

import seaborn as sns
import matplotlib.pyplot as plt

# Box plot of Age by Year (every 20 years interval)
plt.figure(figsize=(14, 6))
sns.boxplot(x='Year', y='Age', data=olympic_120_selected)
plt.xticks(rotation=45)
plt.title('Age Distribution of Athletes Over 120 Years')
plt.show()

import plotly.express as px

# Remove rows where Medal is None or NaN
medal_winners = olympic_120_selected[
    (olympic_120_selected['Medal'].notna()) &
    (olympic_120_selected['Medal'] != 'None') &
    (olympic_120_selected['Medal'] != '')
]

fig = px.scatter_geo(
    medal_winners,
    locations='NOC',         # Country codes
    color='Medal',           # Gold, Silver, Bronze
    hover_name='Team',       # Country name
    animation_frame='Year',  # Animate by Year
    projection="natural earth",
    title="Medal Winners Distribution Over 120 Years"
)

fig.show()

# Example: medals over years (from 120 Years dataset)
medals_year_gender = olympic_120yrs_df.groupby(['Year','Gender'])['Medal_Won'].sum().unstack()
medals_year_gender.plot(kind='area', stacked=True, figsize=(12,6), cmap='coolwarm')
plt.title("120 Years Olympics: Medals Over Time by Gender")
plt.ylabel("Total Medals")
plt.show()

import pandas as pd

# 1️⃣ Convert birth_date to datetime
paris_df['birth_date'] = pd.to_datetime(paris_df['birth_date'], errors='coerce')

# 2️⃣ Define the reference date (Paris 2024 Olympics)
olympics_date = pd.to_datetime('2024-07-26')

# 3️⃣ Calculate Age
paris_df['Age'] = (olympics_date - paris_df['birth_date']).dt.days // 365

# 4️⃣ Create Age Categories
bins = [0, 19, 29, 39, 100]
labels = ['<20', '20-29', '30-39', '40+']
paris_df['Age_Category'] = pd.cut(paris_df['Age'], bins=bins, labels=labels)

# 5️⃣ Optional: check the result
paris_df[['Name', 'birth_date', 'Age', 'Age_Category']].head()

import plotly.express as px

country_medals = olympic_120yrs_df.groupby('NOC')['Medal_Won'].sum().reset_index()
fig = px.choropleth(country_medals, locations='NOC', color='Medal_Won', title="120 Years Olympics: Medals by Country")
fig.show()

# Keep only rows where Medal is not NaN
medal_df = olympic_120yrs_df[olympic_120yrs_df['Medal'].notna()]
# Group by Year, Sport, and Country; count medals
medals_per_country = medal_df.groupby(['Year', 'Sport', 'Team'])['Medal'].count().reset_index()
medals_per_country.rename(columns={'Medal': 'Medal_Count'}, inplace=True)
# For each Year and Sport, find the country with the maximum medals
top_country_per_sport = medals_per_country.loc[
    medals_per_country.groupby(['Year', 'Sport'])['Medal_Count'].idxmax()
].reset_index(drop=True)

top_country_per_sport.head()

import seaborn as sns
import matplotlib.pyplot as plt

# Pivot for heatmap: Sport x Year, values = Medal_Count of top country
heatmap_data = top_country_per_sport.pivot(index='Sport', columns='Year', values='Medal_Count')

plt.figure(figsize=(20,10))
sns.heatmap(heatmap_data, annot=True, fmt=".0f", cmap="YlGnBu")  # ".0f" rounds floats to integers
plt.title("Top Country Medal Count per Sport Over 120 Years")
plt.xlabel("Year")
plt.ylabel("Sport")
plt.show()

plt.figure(figsize=(10,6))
sns.histplot(
    paris_df[paris_df['Medal'].notna()]['Age'],
    bins=10,
    kde=True,
    color='skyblue'
)
plt.title('Age Distribution of Medal Winners')
plt.xlabel('Age')
plt.ylabel('Number of Athletes')
plt.show()